---
title: Git与Github
tags: git
categories: 技术
comments: true
---

### Git与Github

<!--more-->

#### 1. 开始

**版本控制**，版本控制系统是帮助你控制（或管理）某个事物（通常是源码）的不同版本。

版本控制系统模型包括两大主要类型：

- **集中式模型**-所有用户都连接到一个中央的主仓库（master repository）
- **分布式模型**-每个用户都在自己的计算机上拥有完整的仓库

版本控制系统的主要目的是帮助你保留项目的详细历史记录，并且能够在不同的版本上进行工作。保留详细的项目历史记录很重要，因为这样可以看出一段时间内项目的进度。如果需要，你还可以回到项目的某个阶段，并恢复数据或文件。

在这里，我们将使用分布式版本控制系统 Git来进行版本控制。

---

**术语**

**版本控制系统 / 源代码管理器**

版本控制系统（简称 VCS）是一个管理源代码不同版本的工具。源代码管理器（简称 SCM）是版本控制系统的另一个名称。

Git 是一个 SCM（因此也是 VCS！）。Git 网站的 URL 是 https://git-scm.com/ （注意它的域名中直接包含“SCM”！）。

**提交（Commit）**

Git 将数据看做微型文件系统的一组快照。每次 commit（在 Git 中保持项目状态），它都对文件当时的状况拍照，并存储对该快照的引用。你可以将其看做游戏中的保存点，它会保存项目的文件和关于文件的所有信息。

你在 Git 中的所有操作都是帮助你进行 commit，因此 commit 是 Git 中的基本单位。

**仓库（Repository/repo）**

仓库是一个包含项目内容以及几个文件（在 Mac OS X 上默认地处于隐藏状态）的目录，用来与 Git 进行通信。仓库可以存储在本地，或作为远程副本存储在其他计算机上。仓库是由 commit 构成的。

**工作目录 / 工作区（Working Directory）**

工作目录是你在计算机的文件系统中看到的文件。当你在代码编辑器中打开项目文件时，你是在工作目录中处理文件。

与这些文件形成对比的是保持在仓库中（在 commit 中！）的文件。

在使用 Git 时，工作目录与命令行工具的 current working directory （当前工作目录）不一样，后者是 shell 当前正在查看的目录。

**检出（Checkout）**

检出是指将仓库中的内容复制到工作目录下。

**暂存区 / 暂存索引 / 索引（Staging Area / Staging Index / Index）**

Git 目录下的一个文件，存储的是即将进入下个 commit 内容的信息。可以将暂存区看做准备工作台，Git 将在此区域获取下个 commit。暂存索引中的文件是准备添加到仓库中的文件。

**SHA**

SHA 是每个 commit 的 ID 编号。以下是 commit 的 SHA 示例：`e2adf8ae3e2e4ed40add75cc44cf9d0a869afeb6`。

它是一个长 40 个字符的字符串（由 0–9 和 a–f 组成），并根据 Git 中的文件或目录结构的内容计算得出。SHA 的全称是"Secure Hash Algorithm"（安全哈希算法）。

**分支（Branch）**

分支是从主开发流程中分支出来的新的开发流程。这种分支开发流程可以在不更改主流程的情况下继续延伸下去。

回到之前关于游戏保存点的示例，你可以将分支看做在游戏中设立保存点后，尝试一个有风险的招式。如果有风险的招式不奏效，则回到保存的位置。令分支非常强大的关键之处是你可以在一个分支上设定保存点，然后切换到另一个分支并继续设定保存点。

了解这些术语后，我们将探寻使用版本控制的一般流程，从更高的层面了解如何使用 Git。

---

**初次配置Git**

在开始使用 Git 之前，你需要配置 Git。在命令行工具中运行以下每行，确保所有选项都已被配置好。

```
# 设置你的 Git 用户名
git config --global user.name "<Your-Full-Name>"

# 设置你的 Git 邮箱
git config --global user.email "<your-email-address>"

# 确保 Git 输出内容带有颜色标记
git config --global color.ui auto

# 对比显示原始状态
git config --global merge.conflictstyle diff3

git config --list
```

**Git 与代码编辑器**

最后一个配置步骤是让 Git 能与你的代码编辑器结合使用。以下是三个最热门的代码编辑器。如果你使用的是其他编辑器，则在 Google 中搜索“修改 Git 默认编辑器为 X 编辑器”（将 X 替换为你的代码编辑器的名称）。

**Atom Editor 设置**

```
git config --global core.editor "atom --wait"
```

**Sublime Text 设置**

```
git config --global core.editor "'/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl' -n -w"
```

**VSCode 设置**

```
git config --global core.editor "code --wait"
```

---

#### 2. 创建Git仓库

`git init` / `git clone` / `git status`

---

在对 Git 仓库进行 commit 或执行任何其他操作之前，需要一个实际存在的仓库。要使用 Git 新建一个仓库，我们将使用 `git init` 命令。

`init` 子命令是"initialize"（初始化）的简称，这个命令很有用，因为它将进行所有仓库初始设置。稍后我们将了解它的作用。

**git init 命令的作用**

运行 `git init` 命令会初始化 Git 跟踪所有内容会用到的所有必要文件和目录。所有这些文件都存储在叫做 `.git`（注意开头有个 .，表示在 Mac/Linux 上，它将是一个隐藏目录）的目录下。这个 `.git` 目录是一个库！Git 会将所有 commit 记录在这里，并跟踪所有内容！

我们来大致了解下 `.git` 目录下的内容。

> 警告：请勿直接修改 .git 目录下的任何文件。这是仓库的核心。如果你更改了文件名或文件内容，Git 可能就无法跟踪你保存在仓库中的文件，你可能会丢失很多内容！可以查看这些文件，但是请勿编辑或删除这些文件。

**.git 目录内容**

我们将查看 `.git` 目录…不用记住任何内容，但是你可以在此处深入了解 Git 背后的工作原理。

下面简要概述了 .git 目录下的各项内容：

- 配置文件-存储了所有与项目相关的配置设置。

Git 会查看 Git 目录下你当前所使用仓库对应的配置文件（.git/config）中的配置值。这些值仅适用于当前仓库。

假设你将 Git 全局配置为使用你的个人电子邮箱。如果你想针对某个项目使用你的工作邮箱，则此项更改会被添加到该文件中。

- description 文件 - 此文件仅用于 GitWeb 程序，因此可以忽略

- hooks 目录 - 我们会在此处放置客户端或服务器端脚本，以便用来连接到 Git 的不同生命周期事件

- info 目录 - 包含全局排除文件

- objects 目录 - 此目录将存储我们提交的所有 commit

- refs 目录 - 此目录存储了指向 commit 的指针（通常是“分支”和“标签”）

注意，除了 hooks 目录，你应该不会对这里的其他内容有太多的困扰。hooks 目录可以用来连接到 Git 工作流的不同部分或事件，在这不做深入研究。

**git init 小结**

使用 `git init` 命令可以在当前目录下创建新的空仓库。

```
$ git init
```

运行此命令可以创建隐藏 `.git` 目录。此 `.git` 目录是仓库的核心/存储中心。它存储了所有的配置文件和目录，以及所有的 commit。

---

**克隆现有仓库**

在 Git 上进行克隆的方法是调用我们将在终端上运行的命令 `git clone`，然后传入要克隆的 Git 仓库的路径（通常是 URL）。

**克隆 blog 仓库**

输入命令 `git clone`，然后输入你要克隆的 Git 仓库的路径。

```
$ git clone https://github.com/enningxie/Coolixz  
```

`git clone` 命令用于创建一个与现有仓库完全相同的副本。

```
$ git clone <path-to-repository-to-clone>
```

该命令：

- 会获取现有仓库的路径

- 默认地将创建一个与被克隆的仓库名称相同的目录

- 可以提供第二个参数，作为该目录的名称

- 将在现有工作目录下创建一个新的仓库

---

**判断仓库的状态**

在命令行中使用 Git 可能会有点挑战，因为它有点类似于黑箱。如何判断你是否需要运行某些 Git 命令？ Git 是否已经准备好运行某个命令？ 如果我运行了一个命令，但我认为它并未被执行，我该如何进行验证呢？ `git status` 命令可以回答所有这些问题！

```
$ git status
```

`git status` 是了解 Git 的核心所在。它将告诉我们 Git 正在考虑什么，以及 Git 所看到的我们仓库的状态。当你第一次使用 Git 时，你应该一直都要使用 `git status` 命令！说真的，你应该习惯于运行任何其他命令之后，都运行下该命令。这样可以帮助你了解 Git 的工作原理，并避免你对文件 / 仓库状态做出不正确的推论。

`git status` 命令将显示很多信息，具体取决于你的文件状态、工作目录和仓库。但是你不需要过于关心这些内容…只需运行 `git status`，它将显示你需要知道的信息。

`git status` 的输出结果将有所不同，具体取决于文件是否被添加/删除/修改、暂存索引的情况，以及仓库的状态。

`git status` 命令将显示仓库的当前状态。

我一直在强调这个命令非常的重要，因为这是你第一次使用 Git。该命令将：

- 告诉我们已在工作目录中被创建但 Git 尚未开始跟踪的新文件

- Git 正在跟踪的已修改文件

- 以及我们将在后续阶段学习的很多其他信息 ;-)。

---

#### 3. 查看仓库的历史记录

`git log` / `git show`

---

我们快速总结下 `git log` 命令。`git log` 命令用于显示仓库中所有 commit 的信息。

```
$ git log
```

默认情况下，该命令会显示仓库中每个 commit 的：

- SHA

- 作者

- 日期

- 消息

我强调了“默认情况下”是因为 `git log` 命令显示的信息远不止这些。

git 使用命令行分页器 less 浏览所有信息。以下是 less 的重要快捷键：

- 要按行向下滚动，使用 `j` 或 `↓`

- 要按行向上滚动，使用 `k` 或 `↑`

- 要按页向下滚动，使用空格键或 Page Down 按钮

- 要按页向下滚动，使用 `b` 或 Page Up 按钮

- 要退出，使用 `q`

我们已经仔细了解了 `git log` 显示的详细信息。思考一下这些问题：

- SHA - `git log` 将显示每个 commit 的完整 SHA。每个 SHA 都是唯一的，因此，我不需要查看整个 SHA。只需知道前 6-8 个字符即可。如果我们能只显示 SHA 的前 5 个左右的字符，是不是会节省一些空间？

- 作者 - `git log` 输出结果显示了每个 commit 的作者！其他仓库可能有多个人协作，因此情况可能不同，但是对于此仓库，只有一个人提交了所有的 commit，因此所有 commit 的作者是一样的。我们需要查看每个 commit 的作者吗？如果我们想隐藏这一信息呢？

- 日期 - 默认情况下，git log 将显示每个 commit 的日期。但是我们真的关心 commit 的日期吗？知道日期有时会很重要，但是每次都知道日期并不十分重要，在很多情况下都可以忽略。能否隐藏该信息，以便节省空间？

- commit 消息 - 这是 commit 消息最重要的部分…我们通常都希望看到此信息

如何使输出结果更简短，并节省大量空间？我们可以使用 `选项`。

**git log --oneline**

`git log` 命令有一个选项，可以用来更改仓库信息的显示方式。该选项为 `--oneline`：

```
$ git log --oneline
```

此命令：

- 每行显示一个 commit

- 显示 commit 的 SHA 的前 7 个字符

- 显示 commit 的消息

**`git log --stat` 简介**

`git log` 命令有一个选项可以用来显示 commit 中更改的文件以及添加或删除的行数。该选项为 `--stat`（stat 是“统计信息 statistics”的简称）:

```
$ git log --stat
```

此命令会：

- 显示被修改的文件

- 显示添加/删除的行数

- 显示一个摘要，其中包含修改/删除的总文件数和总行数

**查看更改**

`git log -p`

`git log` 命令具有一个可用来显示对文件作出实际更改的选项。该选项是 `--patch`，可以简写为 `-p`：

```
$ git log -p
```

此命令会向默认输出中添加以下信息：

- 显示被修改的文件

- 显示添加/删除的行所在的位置

- 显示做出的实际更改

**查看特定的commit**

实际上有两种实现方式！

- 向 `git log` 提供你要查看的 commit 的 SHA

- 使用新的 `git show` 命令

它们都很简单，我们先学习 `git log` 方式，然后再学习 `git show`。

你已经知道如何使用以下命令输出信息：

- `git log`

- `git log --oneline`

- `git log --stat`

- `git log -p`

但是你是否知道，可以向所有这些命令提供 commit 的 SHA 作为最后一个参数？例如：

```
$ git log -p fdf5493
```

通过提供 SHA，`git log -p` 命令将从这条 commit 开始！无需滚动并逐条查阅！注意，它还会显示在所提供的 SHA 之前提交的所有 commit 信息。

**新命令：`git show`**

一个显示特定 commit 的命令是 `git show`：

```
$ git show
```

运行上述示例命令将仅显示最近的 commit。通常，将 SHA 作为最后一个参数提供给命令：

```
$ git show fdf5493
```

**`git show` 的作用是？**

`git show` 命令将仅显示一个 commit。因此，如果你看不到任何其他 commit，不要惊慌。它只显示一个 commit。`git show` 命令的输出和 `git log -p` 命令的完全一样。因此默认情况下，git show 会显示：

- commit

- 作者

- 日期

- commit消息

- 补丁信息

但是，`git show` 可以与我们了解过的大部分其他选项一起使用：

- `--stat` - 显示更改了多少文件，以及添加/删除的行数

- `-p` 或 `--patch` - 显示默认补丁信息，但是如果使用了 `--stat`，将不显示补丁信息，因此传入 `-p` 以再次添加该信息

- `-w` - 忽略空格变化

---

#### 4. 向仓库中添加commit

`git add` / `git commit` / `git diff`

可以使用 `git add` 命令将文件从工作目录移到暂存区

顺便提下，`git rm --cached` 与 shell 的 `rm` 命令不同。`git rm --cached` 不会破坏任何属于你的文件，它只是从暂存区删掉了文件。

**句点`.`**

句点指代当前目录，可以用来表示所有文件和目录（包括所有嵌套文件和目录！）。

```
$ git add .
```

唯一要注意的是，你可能会不小心包含多余的文件。

`git add` 命令用于将文件从工作目录移到暂存区。

```
$ git add <file1> <file2> … <fileN>
```

此命令：

- 可接受多个文件名（用空格分隔）

- 此外，可以使用句点 `.` 来代替文件列表，告诉 git 添加当前目录至暂存区（以及所有嵌套文件）

**提交 Commit**

要在 git 中提交 commit，你需要使用 `git commit` 命令，但是先别运行这条命令。运行这条命令将会打开你在之前配置的代码编辑器。如果你尚未运行以下命令：

```
$ git config --global core.editor <your-editor's-config-went-here>
```

回到 git 配置步骤并让 git 使用你所选的编辑器。

如果你尚未执行这一步骤并且已经运行 `git commit`，那么 git 可能会默认使用 Vim 编辑器。Vim 很受 Unix 或 Linux 系统用户的欢迎，但是对新用户来说，并不太好用。

使用 `-m` 选项绕过编辑器

提示：如果你要编写的提交说明很简短，不想等打开代码编辑器后再输入信息，可以直接在命令行中使用 `-m` 选项传入信息：

```
$ git commit -m "Initial commit"
```

在上述示例中，文本`"Initial commit"`被作为提交说明信息。但是注意，不能为 commit 提供信息的描述（description），只能提供信息部分（message）。

**git commit 小结**

`git commit` 命令会取出暂存区的文件并保存到仓库中。

```
$ git commit
```

此命令：

- 将打开配置中指定的代码编辑器

在代码编辑器中：

- 必须提供提交说明

- 以 `#` 开头的行是注释，将不会被记录

- 添加提交说明后保存文件

- 关闭编辑器以进行提交

然后使用 `git log` 检查你刚刚提交的 commit！

---

你可能会像我一样，在晚上开始构建项目的下个功能，但是在完成之前就去睡觉了。也就是说，当我第二天开始工作的时候，有一些没有提交的更改。这很正常，因为我还没有完成新的功能，但是我不记得自上次 commit 起我到底完成了哪些代码。`git status` 将告诉我们哪些文件更改了，但是不会显示到底是什么样的更改。

`git diff` 命令可以用来查找此类信息！

**`git diff`**

The `git diff` 命令可以用来查看已被加入但是尚未提交的更改。

此命令会显示：

- 已经修改的文件

- 添加/删除的行所在的位置

- 执行的实际更改

---

**让git忽略某些文件**

还记得在之前学习的 `git add` 吗？我们可以使用一个特殊的字符来表示当前目录和所有子目录，而不用一个个地添加文件。还记得是什么字符吗？

没错，是句点 (`.`)！

**gitignore**

如果你想将某个文件保留在项目的目录结构中，但是确保它不会意外地提交到项目中，可以使用名称特殊的文件 `.gitignore`（注意文件名开头的点，很重要！）。将此文件添加到项目中隐藏的 `.git` 目录。你只需列出希望 git ignore（忽略，不跟踪）的文件名，git 将忽略这些文件。

通配符允许你使用特殊的字符来表示某些格式/字符。在 `.gitignore` 文件中，你可以使用：

- 空白行作为空格

- `#` - 将行标记为注释

- `*` - 与 0 个或多个字符匹配

- `?` - 与 1 个字符匹配

- `[abc]` - 与 a、b 或 c 匹配

- `**` - 与嵌套目录匹配 - `a/**/z` 与以下项匹配: a/z, a/b/z, a/b/c/z

因此如果所有 50 个图片都是 JPEG 图片，并且位于"samples"文件夹中，那么我们可以向 `.gitignore` 中添加以下行，使 git 忽略所有这 50 个图片。

```
samples/*.jpg
```

总结下，`.gitignore` 文件用来告诉 git 不应跟踪的文件。该文件应该放在 `.git` 目录所在的目录。

---

#### 5. 标签、分支和合并

`git tag` / `git branch` / `git checkout` / `git merge`

**git tag 命令**

注意所显示的结果（只需注意 SHA 和 commit 消息）

我们将使用 `git tag` 命令与仓库的标签进行交互：

```
$ git tag -a v1.0
```

上述命令将打开代码编辑器，并等待你为标签输入信息。

> 注意：在上述命令 (`git tag -a v1.0`) 中，使用了 `-a` 选项。该选项告诉 git 创建一个带注释的标签。如果你没有提供该选项（即 `git tag v1.0`），那么它将创建一个轻量级标签。

建议使用带注释的标签，因为它们包含了大量的额外信息，例如：

- 标签创建者

- 标签创建日期

- 标签消息

因此，你应该始终使用带注释的标签。

**验证标签**

保存并退出编辑器后，命令行上什么也不会显示。那么如何知道已经向项目中添加了标签呢？只需输入 `git tag`，命令行会显示仓库中的所有标签。

**删除标签**

如果将标签消息中的某个字打错了，或标签名称打错了（输入 `v0.1`，而不是 `v1.0`），如何修正这个错误？最简单的方法是删除这个标签并重新创建。

可以通过输入 `-d` 选项 （表示 delete 删除！）加上标签名称来删除 git 标签：

```
$ git tag -d v1.0
```

**向以前的 commit 添加标签**

运行 `git tag -a v1.0` 将为最近的 commit 添加标签。但是如果你想向仓库中很久之前的 Commit 添加标签呢？

只需提供要添加标签的 commit 的 SHA 即可！

```
$ git tag -a v1.0 a87984
```

在弹出代码编辑器以便让你提供标签消息之后）此命令将向 SHA 为 `a87084` 的 commit 添加标签 `v1.0`。借助这一技巧，你可以为整个 git 仓库中的任何 commit 添加标签！很强大吧？并且只需在你已经知道的 git 标签命令中加上 commit 的 SHA 即可。

**git tag 小结**

总结下，`git tag` 命令用来标记特定的 commit 。当添加新的 commit 时，标签不会移动。

```
$ git tag -a beta
```

此命令将：

- 向最近的 commit 添加标签

- 如果提供了 SHA，则向具体的 commit 添加标签

---

现在该学习强大的分支功能了！git 中的分支非常灵活，使你能够实现一些很强大的功能。

**`git branch` 命令**

`git branch` 命令用来与 git 的分支进行交互:

```
$ git branch
```

它可以用来：

- 列出仓库中的所有分支名称

- 创建新的分支

- 删除分支

**创建分支**

要创建分支，只需使用 `git branch` 并提供要创建的分支对应的名称。因此，如果你想创建一个叫做"sidebar"的分支，只需运行以下命令：

```
$ git branch sidebar
```

**`git checkout` 命令**

注意，在进行 commit 时，该 commit 将添加到当前分支上。虽然我们创建了新的 `sidebar` 分支，但是没有向其添加新的 commit，因为我们尚未切换到该分支。如果我们现在进行 commit 的话，该 commit 将添加到 `master` 分支，而不是 `sidebar` 分支。要在分支之间进行切换，我们需要使用 git 的 `checkout` 命令。

```
$ git checkout sidebar
```

请务必了解该命令的工作方式。运行该命令将：

- 从工作目录中删除 git 跟踪的所有文件和目录（git 跟踪的文件存储在仓库中，因此什么也不会丢失）

- 转到仓库，并提取分支指向的 commit 所对应的所有文件和目录

因此此命令将删除 master 分支中的 commit 引用的所有文件。它会将这些文件替换为 sidebar 分支中的 commit 引用的文件。理解这一部分十分重要，所以请务必多读几遍工作方式。

**活跃分支**

提示符将显示活跃分支。但这是我们对提示符进行的特殊自定义，如果你使用的是不同的计算机，判断活跃分支的最快速方式是查看 `git branch` 命令的输出结果。活跃分支名称旁边会显示一个星号。

**删除分支**

分支用来进行开发或对项目进行修正，不会影响到项目（因为更改是在分支上进行的）。在分支上做出更改后，你可以将该分支组合到 `master` 分支上（这种“分支组合过程”叫做“合并”（merge），稍后将详细讲解）。

合并了分支的更改后，你可能不再需要该分支了。如果你想删除分支，可以使用 -d 选项。下面的命令包含 `-d` 选项，告诉 git 删掉给出的分支（这里是"sidebar"分支）。

```
$ git branch -d sidebar
```

注意，无法删除当前所在的分支。因此要删除 `sidebar` 分支，你需要切换到 `master` 分支，或者创建并切换到新的分支。

删除内容让人比较紧张。但是不用担心。如果某个分支上有任何其他分支上都没有包含的 commit（也就是这个 commit 是要被删除的分支独有的），git 不会删除该分支。如果你创建了 `sidebar` 分支，向其添加了 commit，然后尝试使用 `git branch -d sidebar`删除该分支，git 不会让你删除该分支，因为你无法删除当前所在的分支。如果你切换到 `master` 分支并尝试删除 `sidebar` 分支，git 也不会让你删除，因为 `sidebar` 分支上的新 commit 会丢失！要强制删除，你需要使用大写的 D 选项 - `git branch -D sidebar`。

**git branch 小结**

总结下，`git branch` 命令用来管理 git 中的分支：

```
# 列出所有分支

$ git branch


# 创建新的"footer-fix"分支

$ git branch footer-fix


# 删除"footer-fix"分支

$ git branch -d footer-fix
```

此命令用来：

- 列出本地分支

- 创建新的分支

- 删除分支

---

目前，我们处理分支的方式是使用 `git branch` 命令创建一个分支，然后使用 `git checkout` 命令切换到这个新建的分支。

但是你知道吗？`git checkout` 命令也可以创建一个新的分支。如果你添加 `-b` 选项，则能够用一个命令创建分支并切换到该分支。

```
$ git checkout -b richards-branch-for-awesome-changes
```

这是一个很实用的命令，我经常会用到它。

  我们使用新的 `git checkout` 命令来创建新的 `footer` 分支并让此 `footer` 分支的起点位置与 `master` 分支的一样：

  ```
  $ git checkout -b footer master
  ```

  用`git log`命令来显示当前仓库的分支情况：

  ```
  $ git log --oneline --decorate --graph --all
  ```

  `--graph` 选项将条目和行添加到输出的最左侧。显示了实际的分支。`--all` 选项会显示仓库中的所有分支。

---

注意，主题分支（例如 sidebar）的作用是让你做出不影响 master 分支的更改。当你在主题分支上做出更改后，如果觉得不想要该分支上的更改，则可以删掉该分支，或者你决定要保留更改，则可以将该分支上的更改与其他分支上的更改合并。

将分支组合到一起称为**合并**。

git 可以自动将不同分支上的更改合并到一起。这种分支和合并功能正是 git 的强大之处！你可以在分支上做出小的或大的更改，然后使用 git 合并这些更改。

如果你在错误的分支上进行了合并，可以使用以下命令撤消合并：

```
$ git reset --hard HEAD^
```

确保包含 ^ 字符！它属于“相对 commit 引用”并表示“父级 commit”。

**合并指令**

`git merge` 指令用来合并 git 分支：

```
$ git merge <name-of-branch-to-merge-in>
```

发生合并时，git 将：

- 查看将合并的分支

- 查看分支的历史记录并寻找两个分支的 commit 历史记录中都有的单个 commit

- 将单个分支上更改的代码行合并到一起

- 提交一个 commit 来记录合并操作

git 能够灵活地合并不同分支上的大量工作。但是，有时候也无法合并分支。如果在进行合并时失败了，则称为**合并冲突**。

**合并小结**

总结下，`git merge` 命令用来在 git 中合并分支：

```
$ git merge <other-branch>
```

合并有以下两种类型：

- 快进合并 – 要合并的分支必须位于检出分支前面。检出分支的指针将向前移动，指向另一分支所指向的同一 commit。

- 普通类型的合并: 两个完全不同的分支被合并/创建一个合并 commit

大部分情况下，git 将能够成功地合并分支。但是，有时候 git 无法完全自动地进行合并。合并失败时，就称为合并冲突。

如果出现合并冲突，git 将尝试尽可能合并多的内容，然后将留下特殊选项（例如 `>>>` 和 `<<<`），告诉你（没错，告诉作为程序员的你！）需要从何处手动修复。

**合并冲突指示符解释**

编辑器具有以下合并冲突指示符：

- `<<<<<<< HEAD` 此行下方的所有内容（直到下个指示符）显示了当前分支上的行

- `||||||| merged common ancestors` 此行下方的所有内容（直到下个指示符）显示了原始行的内容

- `=======` 表示原始行内容的结束位置，之后的所有行（直到下个指示符）是被合并的当前分支上的行的内容

- `>>>>>>> heading-update` 是要被合并的分支（此例中是 heading-update 分支）上的行结束指示符

**解决合并冲突**

git 使用合并冲突指示符来告诉你两个不同分支上的哪些行导致了合并冲突，以及原始行是什么。要解决合并冲突，你需要：

1. 选择保留哪些行

2. 删掉所有带指示符的行

**commit 合并冲突**

删掉所有包含合并冲突指示符的行并选择保留哪个标题后，直接保存文件，并将其添加到暂存区，然后 commit！就像普通合并一样，代码编辑器会弹出，并让你提供 commit 消息。和之前一样，我们经常会使用自动生成的合并 commit 消息，因此在编辑器打开后，直接关闭编辑器并使用自动生成的 commit 消息。

就这些内容！当你明白合并指示符所显示的内容后，合并冲突就没那么复杂了。

**合并冲突小结**

当相同的行在要合并的不同分支上做出了更改时，就会出现合并冲突。git 将在合并途中暂停，并告诉你存在冲突，以及哪些文件存在冲突。要解决文件中的冲突：

- 找到并删掉存在合并冲突指示符的所有行

- 决定保留哪些行

- 保存文件

- 暂存文件

- 提交commit

注意一个文件可能在多个部分存在合并冲突，因此检查整个文件中的合并冲突指示符，搜索 `<<<` 能够帮助你找到所有这些指示符。

---

#### 6. 撤销更改

`git commit --amend` / `git revert` / `git reset`

更改最近的提交（commit） / 还原提交 / 删除提交

---

**更改最后一个commit**

你已经使用 `git commit` 命令提交了大量的 commit。现在，借助 `--amend` 选项，你可以更改最近的 commit。

```
$ git commit --amend
```

如果你的工作目录没有内容（也就是仓库中没有任何未 commit 的更改），那么运行 `git commit --amend` 将使你能够重新提供 commit 消息。代码编辑器将打开，并显示原始 commit 消息。只需纠正拼错的单词或重新表述即可！然后保存文件并关闭编辑器，以便采用新的 commit 消息。

**向 commit 中添加忘记的文件**

此外，`git commit --amend` 使你能够包含忘记包含的文件（或文件更改）。

你可以修改最后一个 commit 以包含这个忘记的链接。要包含忘记的链接，只需：

- 编辑文件

- 保存文件

- 暂存文件

- 运行 `git commit --amend`

你对必要的文件作出了更改，以便修正被遗忘的链接样式，然后保存所有被修改的文件，并使用 `git add` 暂存所有被修改的文件（就像要提交新的 commit 那样！），但是你可以运行 `git commit --amend` 来更新最近的 commit，而不是创建新的 commit。

**还原commit**

当你告诉 git 还原（revert） 具体的 commit 时，git 会执行和 commit 中的更改完全相反的更改。我们详细讲解下。假设 commit A 添加了一个字符，如果 git 还原 commit A，那么 git 将创建一个新的 commit，并删掉该字符。如果删掉了一个字符，那么还原该 commit 将把该内容添加回来！

**`git revert` 命令**

现在我创建了一个包含一些更改的 commit，我可以使用 `git revert` 命令还原它

```
$ git revert <SHA-of-commit-to-revert>
```

因为最近的 commit 的 SHA 是 `db7e87a`，要还原该 commit： 我需要运行 `git revert` `db7e87a`（随即弹出代码编辑器，以便编辑/确认提供的 commit 消息）

你看到 `git revert` 命令的输出结果是如何告诉我们它还原了什么吗？它输出了我要求它还原的 commit 的提交说明。同时值得注意的是，它创建了新的 commit。

**revert 小结**

总结下，`git revert` 命令用于还原之前创建的 commit：

```
$ git revert <SHA-of-commit-to-revert>
```

此命令：

- 将撤销目标commit所做出的更改

- 创建一个新的commit来记录这一更改

**重置与还原**

初看，重置（reset） 似乎和 还原（revert） 相似，但它们实际上差别很大。还原会创建一个新的 commit，并还原或撤消之前的 commit。但是重置会清除 commit！

一定要谨慎使用 git 的重置功能。这是少数几个可以从仓库中清除 commit 的命令。如果某个 commit 不再存在于仓库中，它所包含的内容也会消失。

为了减轻你的压力，澄清下，git 会在完全清除任何内容之前，持续跟踪大约 30 天。要调用这些内容，你需要使用 `git reflog` 命令。

**相关 commit 引用**

你已经知道可以使用 SHA、标签、分支和特殊的 `HEAD` 指针引用 commit。有时候这些并不足够，你可能需要引用相对于另一个 commit 的 commit。例如，有时候你需要告诉 git 调用当前 commit 的前一个 commit，或者是前两个 commit。我们可以使用特殊的“祖先引用”字符来告诉 git 这些相对引用。这些字符为：

- `^` – 表示父 commit

- `~` – 表示第一个父 commit

我们可以通过以下方式引用之前的 commit：

- 父 commit – 以下内容表示当前 commit 的父 commit

- HEAD^

- HEAD~

- HEAD~1

- 祖父 commit – 以下内容表示当前 commit 的祖父 commit

- HEAD^^

- HEAD~2

- 曾祖父 commit – 以下内容表示当前 commit 的曾祖父 commit

- HEAD^^^

- HEAD~3

`^` 和 `~` 的区别主要体现在通过合并而创建的 commit 中。合并 commit 具有两个父级。对于合并 commit，`^` 引用用来表示第一个父 commit，而 `^2` 表示第二个父 commit。第一个父 commit 是当你运行 git merge 时所处的分支，而第二个父 commit 是被合并的分支。

**`git reset` 命令**

`git reset` 命令用来重置（清除）commit：

```
$ git reset <reference-to-commit>
```

可以用来：

- 将 HEAD 和当前分支指针移到目标 commit

- 清除 commit

- 将 commit 的更改移到暂存区

- 取消暂存 commit 的更改

git reset 的选项:

git 根据所使用选项来判断是清除、暂存之前 commit 的更改，还是取消暂存之前 commit 的更改。这些选项包括：

- `--mixed` default option / move the target commit to `Working Directory`

- `--soft` move the target commit to `Staging index`

- `--hard` move the target commit to `Trash`

> **备份分支**  
注意，使用 `git reset` 命令将清除当前分支上的 commit。因此，如果你想跟着操作接下来出现的所有重置操作，需要在当前 commit 上创建一个分支，以便用作备份。  
在进行任何重置操作之前，我通常会在最近的 commit 上创建一个 `backup` 分支，因此如果出现错误，我可以返回这些 commit：  
```
$ git branch backup
```

> **回到正常状态**  
如果你在重置任何内容前创建了 `backup` 分支，那么你可以轻松地让 `master` 分支指向 `backup` 分支所指向的同一 commit。你只需：  
1. 从工作目录中删除未 commit 的更改  
2. 将 `backup` 合并到 `master`（这将导致快进合并并使 `master` 向上移到和 `backup` 一样的点）

**reset 小结**

总结下，`git reset` 命令被用来清除 commit：

```
$ git reset <reference-to-commit>
```

它可以用来：

- 将 HEAD 和当前分支指针移到引用的 commit

- 使用 `--hard` 选项清除 commit

- 使用 `--soft` 选项将 commit 的更改移至暂存区

- 使用 `--mixed` 选项取消暂存已被 commit 的更改

我们通常会用到祖先引用来指代之前的 commit。祖先引用包含：

- `^` – 表示父 commit

- `~` – 表示第一个父 commit

---

---

### Github 协作

了解如何使用Git与他人合作开发项目

接下来将介绍了处理远程代码库的基本知识。你将能够连接到远程代码库、从远程代码库上获取更改，以及向远程代码库发送更改。你还将学习如何与他人协作。你将 fork 其他开发者的代码库，对该代码库做出更改，然后向他们发送 pull request。你还将掌握一些 Git 技巧，使你能够轻松地与他人合作。

#### 1. 使用远程仓库

**建立协作**

作为一名独立的开发者，你可能喜欢使用本地仓库。接下来，我们将了解远程仓库并与这些远程仓库进行交互。

假设你有一个朋友，我们称她为 Farrin，有一天你们聚到了一起，你向她展示了你近期的工作成果。她提出她可以向此项目添加一些功能。但你不想把自己的电脑给她，让她来进行这些更改，你希望她使用她自己的电脑。另外，你不想在她添加这些功能的时候只是等待，而是继续开发项目，然后在她完成时将她的更改合并进来。我们如何做到这一点呢？

以我的经验，通过来来回回的邮件传达项目的更改，会把后期的维护很快变成一场噩梦。你已经在使用 Git 跟踪项目，那么我们就用它来管理一切事务吧。

所以，Farrin 会在一个特定的分支开发此项目，她会把所做的一些更改添加到该分支上。当她在她的分支上工作的同时，你也会在你自己的特定分支上继续开发此项目。最后，当你获得 Farrin 的分支时，便可以将这两个分支合并在一起。

> **始终使用特性分支**  
记住，在具有描述性命名的特性分支上进行所有 commit 非常有用。分支有助于隔离不相关的更改。  
所以，当你与其他开发者协作时，请确保创建一个新的分支，并使用描述性的名称说明它所包含的更改。

`git remote` / `git push` / `git pull`

管理远程仓库 、 将修改推送到远程仓库上、 从远程仓库获取更新

**远程仓库**

Git 是一个分布式版本控制系统，这意味着不存在一个主信息仓库。每位开发者使用的都是仓库的一个副本。因此，你可以拥有仓库的一个副本（它包含发布的 commit 和版本历史记录），并且你的朋友也可以拥有相同仓库的一个副本。每个仓库包含的信息与其他副本完全相同，没有哪一个是主要的。

在此之前，你可能一直使用的都只是本地仓库。而远程仓库与你的本地 Git 仓库一样，只是它位于其他地方。

**访问远程仓库的方式**

- 使用URL

- 使用系统文件的路径

虽然你也可以在自己的文件系统上创建远程仓库，但这种做法极少见。到目前为止，访问远程仓库的最常见方式是通过位于 Web 上的仓库的 URL。

我们与远程仓库交互和控制远程仓库的方式，是使用 Git 远程命令:

```
$ git remote
```

你并不限于使用一个远程仓库。你可以按需要添加尽可能多的远程仓库。

**为何需要多个远程仓库？**

你为何要用多个远程仓库？我们稍后再谈这个，但简单来说，如果你跟多个开发者合作，那么你就需要在他们合并到 master 分支之前，在项目中获取他们在各自的分支上所做的更改。如果你想在决定实施自己的更改前，测试一下他们的更改，则需要这么做。

另一个例子是，如果你有一个项目，其代码托管在 Github 上，但是又通过 Git 部署到 Heroku 平台上。你需要一个远端 master 用于管理 Github 上的代码，另一个远端 depolyment 用于代码部署。

**添加远程仓库**

现在我们已经了解了远程仓库的用途，我们来将一个远程仓库添加到我们自己的本地仓库。

**git remote 命令**

git remote 命令可以让你管理远程仓库和与之交互。

```
$ git remote
```

如果你尚未配置远程仓库，那么此名称将不会显示任何内容。需要注意的是在你克隆仓库后的情况。如果你克隆了，那么你将自动获得一个远程仓库，因为它是从你所提供的 URL 上的仓库克隆来的。我们来看一个被克隆的仓库。

**远程仓库的简写名（Shortname）**

`git remote` 的输出只是一个单词 `origin`。这挺奇怪的。这里的 "origin" 一词称为"简写名"。简写名只是远程仓库所在位置的简略表示。简写名仅局部用于当前仓库（如在你的本地仓库中）。"origin" 一词是指代主远程仓库的专用名称。你也可以将它重命名为别的东西，但通常会被命名为 "origin"。

我们为何关心引用远程仓库路径的简便性？这是因为，你很快会发现我们将在很多命令中，用到远程仓库的路径。而这时，只使用一个名称就比使用远程仓库的完整路径简单多了。

举个例子，下列哪段描述更好理解：

- 向北行驶大约四分之一英里，然后左转，沿那条路直行约 5 英里，然后右转，直行约 300 英尺，走过蓝色邮箱后，左转至杰克街，前进 50 英尺后再次左转至欧文路，这条路弯弯曲曲，但你最终会到达芬兰巷，然后左手边第三个建筑就是

- 外婆家

可以看出，直接用简写名“外婆家”比写出从当前位置到那里的整个路线要简单得多。

如果你想查看远程仓库的完整路径，只需使用 `-v` 选项即可：

```
$ git remote -v
```

你可以看到，当使用 origin 一词时，实际上使用的是路径，可能有点奇怪：现在有两个远程仓库，都是 "origin" 且链接到相同的 URL。唯一的区别在结尾处： `(fetch)` 部分和 `(push)` 部分。

我们将在后面的部分详细说明 `fetch` 和 `push`。

**在 GitHub 上托管**

托管 Git 项目的方式有多种。但最受欢迎的托管网站被称为 GitHub，你可能以前听说过。现在 GitHub 的问题是，这个名字与 Git 非常相似，有时候人们会将 Git 和 GitHub 混淆，认为它们是完全一样的，而事实上它们大相径庭。

- Git 是一个版本控制工具

- Github 是一个托管 Git 项目的服务

记住 `git remote` 命令用于创建和管理远程仓库。所以我将使用一个命令，在我的本地仓库与 GitHub 帐户上刚创建的远程仓库之间创建连接。

```
$ git remote add origin https://github.com/richardkalehoff/RichardsFantasticProject.git
```

> **远程仓库与权限**  
警告：你需要使用你刚在自己的 GitHub 帐户中创建的新仓库的 URL。请不要使用上面的那个，因此它是我在自己的账户上创建的项目。并且由于此项目在我的帐户上，会导致你无法访问并推送更改。

对于你刚在命令行中运行的命令，有几点需要注意：

1. 首先，这条命令包含一个子命令 `add`

2. 这里使用了 `origin` 一词，设置了我们之前所说的简写名(记住， `origin` 一词并没什么特殊性。如果你想将它改为 `repo-on-GitHub`，那么只需（在运行命令之前）将 "origin" 改为 "repo-on-GitHub"：`$ git remote add repo-on-GitHub https://github.com/richardkalehoff/RichardsFantasticProject.git`)

3. 第三，添加了仓库的完整路径（即 Web 上的远程仓库 URL）

现在，我要使用 `git remote -v` 来验证我已经正确添加了远程仓库。

**小结**

远程仓库与你使用的本地仓库一样，只是存储在不同的位置。要管理远程仓库，可使用 `git remote` 命令：

```
$ git remote
```

- 你可以连接到多个不同的远程仓库。

- 简写名是用于指代远程仓库位置的名称。通常该位置为 URL，但也可能是同一台计算机上的文件路径。

- `git remote add` 用于添加到新的远程仓库的连接。

- `git remote -v` 用于查看远程仓库与连接之间的详细信息。

**推送 commits**

要将本地 commits 推送到远程仓库，你需要使用 `git push` 命令。你要提供远程仓库简写名以及用于容纳你的 commit 的分支名：

```
$ git push <remote-shortname> <branch>
```

我的远程仓库的简写名为 `origin`，并且我想推送的 commit 位于`master`分支上。那么，我要使用以下命令将我的 commit 推送到 GitHub 上的远程仓库：

```
$ git push origin master
```

有几点需要注意：

- 你可能需要输入用户名和密码，这取决于你如何配置 GitHub 的以及使用的远程 URL 。

- 如果你使用的是 `HTTP` 版本（而不是 `ssh` 版本）的远程仓库，就需要提供用户名和密码。

- 如果你配置 GitHub 使用 `SSH` 协议，并提供过 `SSH` 密匙，就不需要执行上一步。

- 如果你要输入用户名和密码，用户名会在输入后显示出来，但密码不会显示。只需继续输入密码，完成后按 Enter 键即可。如果你的密码出错，不用担心，它会让你重新输入。

- Git 会压缩文件使之变小，然后将其推送至远程仓库。

- 这里创建了一个新分支，在页面底部可看到`[new branch]`，后面是 `master -> master`

GitHub 有一个很棒的功能，即它会自动显示 README 文件的内容，这非常有用。

**小结**

`git push` 命令用于从本地仓库向远程仓库推送 commit 。

```
$ git push origin master
```

`git push` 命令需要：

- 你想向其推送 commit 的远程仓库的简写名

- 包含你想推送的 commit 的分支

---

**从远程仓库拉取修改**

假如说我们处于这样一种情况：远程仓库上存在一些 commit ，但我们的本地仓库上没有这些 commit 。这种情况的原因有多个：你参与了团队协作，有一名同事将新更改推送到了远程仓库。或者，你在不同的电脑上开展同一个项目 -- 例如，你有一个办公电脑和一个私人电脑，你在两个电脑上都向仓库做了贡献。如果你从办公电脑上向远程仓库推送更改，则个人电脑上的本地仓库就不会反映这些更改。我们如何将远程仓库上的更改同步到本地仓库呢？这正是我们接下来要看的。我们先来看看拉取远程仓库修改的方式，然后我们将实际操作！

本地仓库中出现的分支实际上在跟踪远程仓库中的一个分支（例如，本地仓库中的 `origin/master` 称为跟踪分支，因为它在跟踪远程仓库上简写名为 "origin" 的 `master` 分支）。

**使用 `git pull` 拉取更改**

记住，`origin/master` 分支不实时映射远程仓库 `master` 分支所在的位置。如果远程仓库的 `master` 分支移动，本地 `origin/master` 分支仍会待在原地。要更新此分支，我们需要同步两个仓库。

`git push` 会同步远程仓库与本地仓库。要执行相反操作（将本地仓库与远程仓库同步），我们需要使用 `git pull`。`git pull` 的格式与 `git push` 的非常相似 - 提供远程仓库的简写名，以及你要拉取 commit 的分支名称。

```
$ git pull origin master
```

运行此代码时需要注意几点:

- 格式与 `git push` 非常相似 - 要对项目计数、压缩和打包

- 它有一个短语 "fast-forward"，这意味着 Git 进行了快进合并（我们一会儿深入研究）

- 它显示类似于 `git log --stat` 的信息，其中显示更改的文件以及添加或删除了多少行

如果你不想自动将本地分支与跟踪分支合并，则不应使用 `git pull`，而是使用另一个命令 `git fetch`。当远程仓库包含你没有的 commit ，但本地仓库也包含远程仓库所没有的 commit 时，你可能想这么做。

**小结**

如果你想在本地仓库中包含远程仓库中的更改，那么你要拉取这些更改。要使用 Git 这样做，你需要使用 `git pull` 命令。你告诉 Git 你想获取修改的远程仓库的简写名以及包含你需要的更改的分支：

```
$ git pull origin master
```

在运行 `git pull` 时，会发生以下活动：

- 远程分支上的 commit 会被复制到本地仓库

- 本地跟踪分支（`origin/master`）移到指向最新的 commit

- 本地跟踪分支（`origin/master`）合并到本地分支（`master`）

**Pull与Fetch**

`git fetch` 用于从远程仓库分支检索 commit ，但不会在收到这些 commit 之后，自动将本地分支与远程跟踪分支合并。

你需要向 `git fetch` 提供和 `git pull` 完全相同的信息，也就是说要提供你想获取的远程仓库的简写名及其分支：

```
$ git fetch origin master
```

运行 `git fetch` 后，会发生以下活动：

- 远程分支上的 commit 会复制到本地仓库

- 本地跟踪分支（例如，`origin/master`）移到指向最新的 commit

需要注意的一点是，本地分支完全不会被改变。

你可以将 `git fetch` 想象成 `git pull` 它的一半操作，而 `git pull` 的另一半是合并。

使用 `git fetch` 而不是 `git pull` 的一个主要情形是当你的远程分支和本地分支都拥有对方所没有的更改时。在这种情况下，你要获取远程更改，将它们存储到本地分支中，然后手动执行合并。最后，你可以将新的合并 commit 推送会远程仓库。

**小结**

你可以将 `git pull` 命令想象成执行两步操作：

1. 获取远程更改（这会将 commit 添加到远程仓库，并移动跟踪分支指向它们）

2. 将本地分支与跟踪分支合并

`git fetch` 命令只执行上面的第一步。它只检索 commit 和移动跟踪分支。它不会将本地分支与跟踪分支合并。提供给 `git pull` 的同样信息也要传递给 `git fetch`：

- 远程仓库的简写名

- 包含要取回的 commit 的分支

```
$ git fetch origin master
```

---

#### 2. 使用其他开发者的仓库

在版本控制术语中，如果你 "fork" 一个仓库，则是指复制它。特别是当你 fork 属于别人的仓库时，你将制作他们仓库的完全一样的副本，之后这个副本便变成你的。

"fork" 的概念也不同于"克隆"。在克隆仓库时，你也会获得完全一样的仓库副本，但克隆发生在本地计算机上，并且克隆的是远程仓库。当你 fork 仓库时，会创建远程仓库的一份新副本。新副本也是一个远程仓库，但它现在属于你。

**fork 推送/拉取**

因为 fork 仓库会使你在自己的帐户中拥有一份副本，所以你可以将其克隆到你的计算机，对其进行更改，然后将这些更改推送回 fork 的仓库。但记住，它会将更改推送回你的远程仓库，而不是被 fork 的原始远程仓库。

**小结**

fork 是一种在托管服务上完成的操作，如 GitHub。fork 仓库会创建与原始仓库完全相同的副本，并将该副本移动到你的帐户。你对 fork 的仓库拥有完全控制权。修改 fork 的仓库不会更改原始仓库。

**查看现有工作**

`git log` 命令非常强大，你可以使用它来深入了解关于仓库的很多信息。而且，它在探索有关你与他人协作的仓库的信息这一方面很实用。你可以使用 `git log` 完成以下任务：

- 使用 `git shortlog` 按作者对 commit 分组  
```
$ git shortlog
```

- 使用 --author 选项筛选 commit  
```
$ git log --author="Richard Kalehoff"
```

- 使用 --grep 选项筛选 commit  
```
$ git log --grep="border radius issue in Safari"
```

---

**你的任务**

假设你正在使用某个第三方库构建一个项目。如果在使用此第三方库时遇到 bug 或拼写错误，该怎么办？虽然你有能力修复它，但你没有直接访问原库进行修改的权限。不过这不是问题，因为你知道 fork 其他开发者的仓库可以将其复制到你的帐户，使你可以全权对它执行 `git pull` 和 `git push`！

但是，当你获得了其他开发者项目的副本，并拥有完全访问权限后，你应该做什么？我们将在下节课学习这一部分，但是如果你 fork 了一个项目，并且你的 fork 中包含原项目所没有的代码，则可以通过向原项目的维护者发送一个请求，将你的代码更改包含在其中，请求维护者将这些更改拉取到原项目中。这种请求称为“拉取请求”（Pull Request）。再次说明，我们将在下一课中介绍发送和使用“Pull Request”。所以，现在你知道如何将你的代码加入到原项目中的方法，并且你想帮助解决这个拼写/代码错误。那么你有任务在身啦！但是，你如何以原项目维护者能接受的方式实际对项目做出贡献，并使他最终合并你的更改？记住，你要做的第一件事，是在项目中寻找一个名为 `CONTRIBUTING.md` 的文件。

**CONTRIBUTING.md 文件**

`CONTRIBUTING.md` 文件的名称特别采用全大写，以方便查找。你可能会从它的名称猜到文件的用途，此文件列出了你要为项目做出贡献时所应遵循的信息。在开始任何开发工作之前，应先找到此文件。

贡献者文件中包含大量信息。所以当你想对一个项目做出贡献时，一定要查阅 CONTRIBUTING.md 文件。

**GitHub Issues**

如果你的代码更改只是修改简单的拼写错误，那么你可以直接进行更改。但如果你要做涉及大量文件的重大修改，则你可能要在开始之前，先获得项目维护者的批准。你肯定不想花几个小时更改项目，最后却发现别人正在做同样的事情。到头来，花费了大量时间和精力做了重复工作。在 CONTRIBUTING.md 文件中，它解释了应该如何规范书写代码，以及你做出贡献的方式，但你如何知道应该贡献什么呢？你应该直接与项目维护人员交谈。GitHub 有一个非常赞的页面，使你能以公开的方式向项目维护者提问，让每个人都能看到项目的动态。

注意，这里说的"Issues（问题）"并不代表实际存在错误，它可以是需要对项目进行的任何改变。GitHub 的问题跟踪器相当高级。每个问题都可以：

- 应用一个或多个标签

- 被分配给个人

- 确定一个里程碑（例如问题将由下一个主要版本解决）

但问题跟踪器最重要的一个方面在于，每个问题都可以有自己的评论区，使开发者围绕这个问题展开对话。

Issue 的另一个很棒的功能在于：

- 你可以订阅某个 Issue ，这样你便会获得新评论和代码更改的通知

- 你可以就具体变更与项目维护者持续交流

在向某个文件贡献任何内容之前，请查看 `CONTRIBUTING.md` 中的说明。然后查看项目的 Issue，看是否有哪些与你要贡献的内容类似。如果有，则订阅该 Issue 并阅读现有的对话，看你是否可以提供帮助。如果你查看了 Issues 列表，没有看到与你要做的事情类似的内容，那么你可以创建自己的新 Issue。在 GitHub 问题界面的每个页面上，都能找到“New Issue（新建问题）”按钮：

**New Issue 页**

新建问题页好的一点在于，如果项目有 CONTRIBUTING.md 文件，它会在页面顶部显示一个提醒，要求你查看有关如何为项目做贡献的准则。点击"guidelines for contributing"链接，可以转至 CONTRIBUTING.md 文件。

GitHub 问题页面支持 Markdown，所以当你创建了自己的问题后，可以使用 Markdown 编排格式，并通过包含链接、图像、项目符号列表和代码块按照你想要的方式进行编写。

与编写描述性的提交说明一样，你在创建问题时，要给它一个信息丰富的标题，简要说明你想要做的事情。然后，在评论部分，提供大量关于此更改的详细信息，可以是你为什么认为此更改有必要，也可以是它如何改进项目。

通常情况下，项目的维护者都有全职工作，只在闲暇时间研究项目，因此，在你急着进行修改前，请给他们一些时间来回答你的问题。一旦项目维护者给予批准，你便可以开始应用想要贡献给项目的更改了。

**特性分支**

组织你想贡献给项目的一系列 commit 或更改的最佳方法，是将它们全部放在一个特性分支上。我说的特性分支是什么意思呢？与主分支不同，主分支是保存整个项目的所有 commit 的默认分支，而特性分支仅保存单个概念或单个更改区域的 commit 。

有很多名称可以用作特性分支的名称。你只需为分支提供一个清晰的描述性名称，以便在列出所有分支时，你可以立即根据名称确定要在分支中做哪些更改。

要记住的一点是，有时项目会对特性分支的命名有特定要求。例如，如果一个分支将要解决错误修复，那么许多项目会要求添加一个 `bugfix-` 前缀。回到我们处理登录表单错误的分支，它得被命名为 `bugfix-login-form`。所以一定要阅读 CONTRIBUTING.md 文件，确定项目是否对特性分支的命名提供了特别说明。

**最佳实践**

**编写描述性的提交说明**

在谈论如何命名分支，以清晰描述分支会包含哪些更改的同时，我想另外提醒一下如何编写清晰、描述性的提交说明。你的分支名称和提交说明描述得越清楚，项目维护者用于询问你的代码的用途，或者自己去深入了解代码的时间就越少。项目维护者需要做的工作越少，将你的更改纳入项目的速度就越快。

**创建短小而明确的 commit**

这一点我们之前已经强调了很多次，请确保在对项目 commit 更改时，使用短小的 commit。不要进行大量 commit，记录 10 多个文件和数百行代码的更改。最好频繁多次地进行小的 commit，只记录很少数量的文件和代码更改。

你可以这样想：如果开发者不喜欢你的大量 commit 中的一部分更改，他们不可能说"我赞成 commit A，只是不赞成改变边栏背景颜色的那部分。" 一个 commit 不能分解成几个小块，所以确保你的 commit 足够小，每个只集中解决一个更改。这样，维护者可以说“我赞成 commit A、B、C、D 和 F，但不赞成 commit E。

**更新 README**

最后，如果你添加的任何代码更改会使项目发生极大的变化，则应更新 README 文件以向其他人说明此更改。

**小结**

在开始任何工作之前，确保阅读项目的 CONTRIBUTING.md 文件。

接下来，查看项目的 GitHub 问题

- 查看现有的问题，看是否有哪些内容类似于你想贡献的更改

- 如有必要，创建一个新的 Issue

- 与项目维护者交流你想要做出的更改

当开始开发后，将所有工作 commit 到特性分支上：

- 不要在主分支上工作

- 确保给特性分支赋予一个清晰、描述性的名称

以及编写 commit 的一般最佳实践

- 频繁少量 commit

- 使用清晰、具有描述性的提交说明

- 必要情况下，更新 README 文件

---

#### 3. 与远程仓库保持同步

Pull Request（拉取请求）是向初始或源仓库的维护者发出的请求，以让其将你在他们项目的 fork 上所做的更改应用在他们的项目中。你请求他们拉取你做的更改。

Pull Request 是让源仓库拉取你的 commit，并融合在其项目中的请求。要创建 Pull Request，你需要完成一些操作：

- 你必须 fork 源仓库

- 将你的 fork 克隆到你的计算机

- 进行一些 commit（最好是在特性分支上！）

- 将 commit 推送回你的 fork

- 创建一个新的 Pull Request，并选择包含你的新 commit 的分支

**Star（收藏）和 Watch（关注）**

如果你想跟进仓库的动态，GitHub 提供了一个非常方便的方式 - 它能让你 star 仓库。

如果你想跟踪特定仓库，star 非常有用。但是，如果你想实时跟进仓库的发展就不行了，你得手动前往收藏页面查看仓库，以检查它们是否发生变化。

Star 是能帮助你跟踪感兴趣仓库的一个有用功能，同时也成为了衡量仓库受欢迎程度的手段。

**Watch 仓库**

如果你要跟进一个项目的变化，并希望接收变更通知，GitHub 为你提供了 "Watch" 功能：

如果你频繁地在一个仓库上工作，那么我建议你将 watch 设置改为"Watching"（持续关注）。这样，当该仓库发生任何活动时，GitHub 都会通知你，例如当有人向仓库推送变更，创建了新的 Issues，或者在现有 Issues 中添加了评论。

**加入上传更改**

现在你了解了 watch 仓库的好处，假设你在 watch 一个仓库，这时收到一个通知说有一些 commit 被推送到了初始源仓库。你如何让这些更改进入你 fork 的仓库副本中？如果你想继续在你的 fork 上进行开发，那么就需要让你 fork 的副本尽可能与源仓库保持同步。

在我的本地仓库中，我已经有一个远程仓库了，那就是 `origin`。

注意 `origin` 一词只是第一次 `git clone` 远程仓库时使用的默认名称。我们将使用 `git remote` 命令来向此列表添加一个新的简写名和 URL。这会提供给我们一个与源仓库之间的连接。

```
$ git remote add upstream https://github.com/udacity/course-collaboration-travel-plans.git
```

注意我使用名称 `upstream` 作为引用源仓库的简写名。与 `origin` 简写名一样，这里的 `upstream` 一词也并不特别；这只是一个常规的词。它可以是任何词... 比如 "banana"。但 "upstream" 一词通常用于引用源仓库。

**Origin 与 Upstream 差别**

现在令人困惑的一点可能是 `origin` 与 `upstream` `之间的差别。其中，origin` 指的不是我们 fork 自的源仓库（也称为"初始"仓库），而是指我们 fork 后的仓库。虽然它叫 `origin`，但实际并不是初始仓库。

记住，`origin `和 `upstream` 只是默认或实际名称。如果你觉得将 origin 远程仓库命名为 mine，upstream 远程仓库命名为 `source-repo` 对你来说更清楚，那么你尽可如此命名。你在本地仓库如何命名远程仓库完全不影响源仓库。

**重置远程仓库名称**


使用 `git remote rename` 命令将 `origin` 重命名为 `mine`，以及将 `upstream` 重命名为 `source-repo`。  

```
$ git remote rename mine origin
$ git remote rename source-repo upstream
```

**拉取上游变更**

现在，要获得上游远程仓库的更改，我们只需运行 `git pull` 并使用 `upstream` 简写名，而不是 `origin` 简写名：

```
$ git pull upstream master
```

使用 `git fetch upstream master` 命令拉取了 `upstream` 远程仓库的 `master` 分支上的更改。

要向 Lam 的仓库推送这些新更改，我们不想运行 `git push origin upstream/master`，因为 `upstream/master` 不是本地分支。要将这些更改融入我 fork 的她的项目版本，我可以将 `upstream/master` 合并到一个现有分支中（例如本地 `master` 分支）然后推送它。

```
# 确保我位于正确的合并分支上
$ git checkout master

# 合并 Lam 的更改
$ git merge upstream/master

# 将 Lam 的更改发送到*我的*远程仓库
$ git push origin master
```

**小结**

当在你 fork 的项目副本上工作时，初始项目的维护者会继续向他们的项目添加更改。你需要将你的 fork 副本与他们的项目保持同步，以包含他们所做的任何更改。

要将源仓库的更改提取到你在 GitHub 上 fork 的仓库副本，你需要：

- 获得源仓库的可克隆 `URL`

- 使用 `git remote add` 命令创建一个新的远程仓库

- 使用简写名 `upstream` 指向源仓库

- 提供源仓库的 URL

- 获取新的 `upstream` 远程仓库

- 将 `upstream` 的分支合并到本地分支

- 将新更新的本地分支推送到你的 `origin` 仓库

---

项目维护者可能不会立即决定接受你的更改。他们可能会要求你对代码做一些额外更改，才会接受你的请求并合并你的更改。他们很可能会通过 Pull Request 页面的 Conversation（对话）传达他们想要的更改。

在提交 Pull Request 时，记住你是要其他开发者将你的代码更改添加到他们的项目。如果他们要求你对你的 Pull Request 做一些小的（甚至是大的！）更改，这并不代表他们拒绝你的工作！只是他们希望以特定方式将你的代码添加到他们的项目中。

你应按照 CONTRIBUTING.md 文件列出项目维护者所需的所有信息，所以请遵照其中的信息。但有时项目维护者可能会要求你做一些其他事情。

那你该怎么做呢？如果你希望你的 Pull Request 被接受，那就执行要求的更改！记住，GitHub 中的选项卡称为"Conversation（对话）"选项卡。所以随时与项目维护者进行沟通，以明确他们希望你做什么。

你也应感谢他们花时间查看你的 Pull Request。大多数开源项目的开发者都是在免费做这些事情，所以记住：

- 善待他人 - 项目维护者只是像你一样的普通人

- 耐心 - 他们会尽快回复

**小结**

就像看起来那么简单，主动发起 commit 请求主要在于沟通！

如果项目维护者要求更改 Pull Request，则：

- 在你的 Pull Request 所基于的本地仓库的同一分支上添加一些必要 commit

- 将该分支推送到你的源仓库 fork 副本

这些 commit 最终将显示在 Pull Request 页面上。

----

**压制commit**

要将 commit 压制在一起，我们要使用非常强大的 `git rebase` 命令。这是我最爱的命令之一，但我的确用了很久才掌握它。起初，我很难搞清楚它的工作原理，然后（在网上读了无数警告之后），我开始害怕实际使用它，因为担心它会不可逆转地破坏我的项目的 Git 历史。

但是现在我想告诉你，`git rebase` 实际并没有那么难，你可以勇敢地对你的仓库进行更改，而无需担心造成任何损害！（<-- 听起来相当鼓舞人心，对不对？！）我们首先概述一下压制的工作原理，然后将实际使用 git rebase 命令进行一些压制。

**rebase 命令**

`git rebase `命令会将 commit 移动到一个新基底（base）上。在命令 `git rebase -i HEAD~3` 中，我们告诉 Git 使用 `HEAD~3` 作为其他所有 commit （`HEAD~2`、`HEAD~1` 和 `HEAD`）将连接到的基底。

命令中的 `-i` 代表"交互式"。你可以在非交互模式下执行 rebase。在你学习如何 rebase 时，我明确建议你进行交互式 rebase。

now you known:

- 如何设置远程仓库

- 如何将更改推送到远程仓库并从中获取更改

- 如何 fork 仓库

- 开始处理新功能或项目更改前，要采取的初步步骤

- 如何创建 Pull Request

- 了解与项目其他利益相关者清楚、频繁沟通的重要性

have fun :)
